{
  "topics": [
    {
      "name": "Testing",
      "levels": [
        {
          "filename": "onboarding.py",
          "blocks": [
            {
              "type": "text",
              "text": "def foo():\n    print(42)\n\n"
            },
            {
              "type": "replace",
              "text": "def bar():\n    print(\"Hello bar!\")\n",
              "replacement": "def greet_user():\n    print(\"Hello\")\n",
              "event": "bar",
              "clickable": "bar",
              "explanation": "No Foos!"
            },
            {
              "type": "text",
              "text": "\n"
            },
            {
              "type": "replace",
              "text": "def BAD_CODE():\n    print(\"BAD\")\n",
              "replacement": "",
              "event": "BAD_CODE",
              "explanation": "Do not write bad code!"
            },
            {
              "type": "text",
              "text": "\n"
            },
            {
              "type": "replace-on",
              "text": "",
              "replacement": "def GOOD_CODE():\n    print(\"ABSOLUTELY GOOD CODE!\")\n",
              "event": "BAD_CODE"
            },
            {
              "type": "replace-span",
              "clickable": "foo",
              "replacement": "nonfoo",
              "event": "foo",
              "explanation": "no foos",
              "hint": "Look at foo!"
            },
            {
              "type": "text",
              "text": "\n"
            },
            {
              "type": "replace-span",
              "clickable": "42",
              "replacement": "the_answer",
              "event": "e42",
              "explanation": "no magic constants!",
              "hint": "42 = 6 * 8"
            }
          ],
          "startMessage": "This is a test level",
          "finalMessage": "Congratulations! You've completed the test level."
        }
      ],
      "inDevelopment": true
    },
    {
      "name": "Naming",
      "levels": [
        {
          "filename": "onboarding.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef main():\n    BaD_VAriABLE_NAME = \"Hello!\"\n    print(BaD_VAriABLE_NAME)\n"
            },
            {
              "type": "replace-span",
              "clickable": "BaD_VAriABLE_NAME",
              "replacement": "greeting",
              "event": "BaD_VAriABLE_NAME",
              "explanation": "Much better! Variable names should be readable by humans, not just compilers with low standards.",
              "hint": "That variable name is begging for mercy. Click it before my eyes bleed!",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to 'greeting'",
                  "correct": true
                }
              ]
            }
          ],
          "startMessage": "Welcome to the coding trenches, Junior!\nAccording to our team traditions (and manager's trust issues), you're not allowed to write code yet. Your sacred duty is to review your colleagues' masterpieces and fix \"small, insignificant issues\".\n\nLet's start with something even you can't mess up. See that variable name that looks like someone fell asleep on their keyboard? Click to fix it before my eyes start bleeding!",
          "startReply": "OK",
          "finalMessage": "Well done! Your journey to becoming slightly less junior has begun!",
          "endReply": "Bring on the next challenge!"
        },
        {
          "filename": "temperature.py",
          "blocks": [
            {
              "type": "text",
              "text": "def fmt_temp(idx, tt):\n    dnms = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    return \"Temperature for \" + dnms[idx] + \" is \" + str(tt) + \"° C\"\n"
            },
            {
              "type": "replace-span",
              "clickable": "idx",
              "replacement": "day_of_week",
              "event": "idx",
              "explanation": "Parameter names should tell a story, not play hide and seek with meaning. 'idx' saves keystrokes but costs clarity.",
              "hint": "Index of what?!",
              "options": [
                {
                  "id": "bad",
                  "label": "Rename to 'index'",
                  "correct": false
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'day'",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'day_of_week'",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'day_of_month'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "tt",
              "replacement": "temperature",
              "event": "tt",
              "explanation": "Abbreviations save seconds typing but cost minutes of confusion. What does 'tt' even mean?",
              "hint": "Imagine that names are the only documentation on this function you have...",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to temperature",
                  "correct": true
                },
                {
                  "id": "bad",
                  "label": "Rename to temp",
                  "correct": false
                },
                {
                  "id": "bad-1",
                  "label": "Rename to t",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "dnms",
              "replacement": "day_names",
              "event": "dnms",
              "explanation": "Vowels aren't just decorative - they make words recognizable! 'dnms' looks like a typo.",
              "hint": "Variable lost its vowels. Perform vowel-donation surgery!",
              "options": [
                {
                  "id": "bad",
                  "label": "Inline variable",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to day_names",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Rename to daynames",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "fmt_temp",
              "replacement": "format_temperature",
              "event": "fmt_temp",
              "explanation": "'fmt_temp' could mean anything from formatting templates to fermenting tempeh.",
              "hint": "Imagine that function name is the only documentation on this function you have...",
              "options": [
                {
                  "id": "bad",
                  "label": "Rename to format_temperature_for_day_of_week",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to format_temperature",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Rename format",
                  "correct": false
                },
                {
                  "id": "bad-2",
                  "label": "Rename fmt",
                  "correct": false
                }
              ]
            },
            {
              "type": "text",
              "text": "\n\nprint(fmt_temp(5, 20))\n"
            }
          ],
          "startMessage": "Oh! Time for some real work! Take a look at this cryptic masterpiece of your colleague and see if you can decipher what's happening without consulting ancient scrolls or summoning a code whisperer.\nLet's make this readable for mere mortals.",
          "finalMessage": "Bravo! Now human might actually understand without needing a decoder ring.\nRemember: code is read far more often than it's written, so clarity trumps brevity every time. Your future teammates (and your future self at 3 AM) will be eternally grateful!",
          "endReply": "Next naming task!"
        },
        {
          "filename": "cells.py",
          "blocks": [
            {
              "type": "text",
              "text": "def get(lst):\n    lst1 = []\n    for c in lst:\n        if c.is_empty: \n            lst1.Add(c.position)\n    return lst1\n\nlst = read_cells(\"cells.csv\")\nprint(get(lst))\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "get",
              "replacement": "get_empty_positions",
              "event": "get",
              "hint": "Is the function's purpose immediately clear from its name?",
              "explanation": "Perfect! A function's name should explain its purpose. We're not playing charades here.",
              "options": [
                {
                  "id": "bad-2",
                  "label": "Add comment for function",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'get_empty_positions'",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'find_empty_data'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "lst1",
              "replacement": "empty_positions",
              "event": "lst1",
              "hint": "Does that name clearly tell you what kind of data it holds?",
              "explanation": "Ah, 'lst1', the pinnacle of descriptive naming! Now, 'empty_positions' actually tells us what it holds. Much clearer, isn't it?",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Rename to 'result_list'",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'empty_positions'",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'filtered_cells'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "lst",
              "replacement": "cells",
              "event": "lst",
              "hint": "Does this name clearly tell you what kind of items are inside?",
              "explanation": "Calling a list 'lst' is like calling your dog 'animal'. 'Cells' tells you exactly what you're dealing with. Much clearer, right?",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Rename to 'items'",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'cells'",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Explain in a comment",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "c",
              "replacement": "cell",
              "event": "c",
              "hint": "Does that single letter really tell you what it is?",
              "explanation": "Using single letters is great for puzzles, but terrible for code. Now 'cell' actually tells us what it is!",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to 'cell'",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'item'",
                  "correct": false
                }
              ]
            }
          ],
          "startMessage": "Well done on your previous fixes! Now your colleague has sent you this \"masterpiece\" of clarity. \n\n\"It's short and simple,\" they said. \"Probably doesn't need any changes,\" they said. Let's see about that... I spy with my little eye some variables that are playing hide-and-seek with their meanings!",
          "finalMessage": "Excellent work! You've transformed this cryptic code into something self-documenting.\nNow anyone reading it can understand what it does without having to trace through the execution in their head.\nRemember: code is written once but read many times, so optimizing for readability is always worth the extra keystrokes!",
          "endReply": "Next challenge!"
        },
        {
          "filename": "views.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef get_views_per_second(views, date):\n"
            },
            {
              "type": "replace-on",
              "event": "MAGIC",
              "text": "",
              "replacement": "    ss = 24 * 60 * 60\n"
            },
            {
              "type": "text",
              "text": "    daily_views = sum(1 for v in views if v.date == date)\n    return daily_views / 86400\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "86400",
              "replacement": "(24*60*60)",
              "event": "86400",
              "hint": "What does this specific number represent? Think about time measurement.",
              "explanation": "Magic numbers 86400 became less magical now. But can you do even better?"
            },
            {
              "type": "replace-span",
              "clickable": "(24*60*60)",
              "replacement": "ss",
              "event": "MAGIC",
              "hint": "Does that calculation explain itself?",
              "explanation": "Good job! Naming that number makes the code much easier to understand. No more head-scratching!",
              "options": [
                {
                  "id": "good",
                  "label": "Extract variable",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Add comment for calculation",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "ss",
              "replacement": "seconds_in_24h",
              "event": "ss",
              "hint": "Can you tell what that number represents just by looking at its name?",
              "explanation": "Finally we are sure that 'ss' is not 'something secret'!",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Rename to 'total_seconds'",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'seconds_in_24h'",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Add a comment for clarity",
                  "correct": false
                }
              ]
            }
          ],
          "startMessage": "⚠️ IMPORTANT NOTICE ⚠️\nDo NOT change any constants here! They are magically calculated by our resident wizard who refuses to document anything.\n\nThe code works perfectly through some arcane sorcery. Touching it might summon demons or worse - break production. Proceed with extreme caution!",
          "finalMessage": "Congratulations on defying the \"don't touch the magic constants\" warning!\nSometimes the most important rules to break are the ones that lead to unmaintainable code.\nBy replacing magic numbers with clear, calculated constants, you've made this code significantly more readable and less prone to mysterious bugs.\nYour future self thanks you!",
          "endReply": "Magic dispelled!"
        },
        {
          "filename": "contains.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef contains(text, pattern):\n    l = len(pattern)\n    for i in range(len(text)):\n        if text[i:i+1] == pattern:\n            return True\n    return False\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "l",
              "replacement": "pattern_len",
              "event": "l",
              "hint": "Single character name often are source of troubles!",
              "explanation": "Lowercase 'l' as a variable name? Good way to mess it with `1` and `I`!",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Rename to 'len'",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'pattern_len'",
                  "correct": true
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "i+1",
              "replacement": "i+l",
              "event": "i1",
              "hint": "The slice is a bit... thin...",
              "explanation": "Off-by-many error? Is it a new level of the off-by-one?",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Replace i",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Use pattern_len",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Rename 'text'",
                  "correct": false
                }
              ]
            }
          ],
          "startMessage": "Your colleague just pushed this \"perfectly working\" string search function to production. Customers are already complaining that the search doesn't work properly.\n\nCan you find what's lurking in this seemingly innocent code before the support team stages a revolt?",
          "startReply": "Challenge accepted!",
          "finalMessage": "Great debugging! You fixed both a naming issue and a logical bug. The original code only compared single characters to the entire pattern. Clear variable names make bugs like this easier to spot!",
          "endReply": "Bug squashed! What's next?"
        },
        {
          "filename": "unescape.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef unescape(s):\n    ss = \"\"\n    flag = False\n    for c in s:\n        if flag and c == 'n':\n            ss += '\\n'\n        elif flag and c == 't':\n            ss += '\\t'\n        elif flag and c == '\\\\':\n            ss += '\\\\'\n        elif c == '\\\\':\n            flag = True\n        else:\n            ss += c\n    return ss\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "flag",
              "replacement": "after_slash",
              "event": "flag",
              "hint": "What condition is this boolean tracking? Think about the previous character.",
              "explanation": "Flag for what? A country? A ship? 'after_slash' actually tells us what it's tracking.",
              "options": [
                {
                  "id": "bad-2",
                  "label": "Add comment explaining 'flag'",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'after_slash'",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'slash'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "ss",
              "replacement": "unescaped",
              "event": "ss",
              "hint": "What transformation is happening to this string as it's being built?",
              "explanation": "'ss'? A snake hissing? Variable names should tell a story, not just duplicate other names.",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Rename to 'escaped'",
                  "correct": false
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'parsed'",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'unescaped'",
                  "correct": true
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "s",
              "replacement": "escaped",
              "event": "s",
              "hint": "What kind of string is being passed to this function?",
              "explanation": "Single-letter variables are mysterious characters never properly introduced. Parameters deserve full identity.",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Rename to 'unescaped'",
                  "correct": false
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'parsed'",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'escaped'",
                  "correct": true
                }
              ]
            }
          ],
          "startMessage": "Behold! Our senior developer's \"typing efficiency\" naming convention:\n- String variables: 's', 's1', 'ss' (saves keystrokes!)\n- Booleans: always 'flag' (saves thinking time!)\n\nThis is a pure efficiency of x10 developers!",
          "startReply": "Don't think so...",
          "finalMessage": "Excellent work! You've transformed this code from a cryptic puzzle into self-documenting code. Now anyone reading it can immediately understand what each variable represents without having to trace through the execution. Remember: the goal of variable naming isn't to save keystrokes while typing - it's to save brain cycles while reading!",
          "endReply": "Names fixed!"
        },
        {
          "filename": "bigrams.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef GetBigramsFrequency(ws):\n    bigramsCount = len(ws) - 1\n    bigramsfrequency = {}\n    for I in range(bigramsCount):\n        bg = ws[I] + ' ' + ws[I + 1]\n        if bg in bigramsfrequency:\n            bigramsfrequency[bg] += 1\n        else:\n            bigramsfrequency[bg] = 1\n    return bigramsfrequency\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "GetBigramsFrequency",
              "replacement": "get_bigrams_frequency",
              "event": "GetBigramsFrequency",
              "hint": "This function name is dressed in CamelCase, but Python functions prefer to slither in snake_case.",
              "explanation": "CamelCase in Python? That's like wearing socks with sandals - technically functional but culturally questionable. Python has its own style guide (PEP 8) that recommends snake_case for functions. Consistency in style makes code more readable for the community.",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to 'get_bigrams_frequency'",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'getBigramsFrequency'",
                  "correct": false
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'getbigramsfrequency'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "bigramsCount",
              "replacement": "bigrams_count",
              "event": "bigramsCount",
              "hint": "CamelCase in Python? That's cultural appropriation!",
              "explanation": "Another CamelCase refugee! In Python, we separate our words with underscores, not capital letters. It's not just pedantry - consistent style makes code easier to scan and understand.",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to 'bigrams_count'",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'counts'",
                  "correct": false
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'bigrams'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "I",
              "replacement": "i",
              "event": "I",
              "hint": "Why is this loop counter SHOUTING at me?",
              "explanation": "A capital 'I' as a loop counter? That's just asking to be confused with the number 1 in many fonts! Single-letter variables should be lowercase, especially common ones like loop counters.",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to 'i'",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'wordIndex'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "ws",
              "replacement": "words",
              "event": "ws",
              "hint": "ws? Web Services? Weighted Sums? Wild Stallions?",
              "explanation": "The mysterious 'ws'! Is it 'web services'? 'work sheets'? 'wild stallions'? Abbreviations save you 3 seconds typing and cost the next developer 3 minutes of confusion.",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Rename to 'web_service'",
                  "correct": false
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'worksheet'",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'words'",
                  "correct": true
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "bg",
              "replacement": "bigram",
              "event": "bg",
              "hint": "bg = Bulgaria? Background? Bill Gates? Buy Gold?",
              "explanation": "'bg' could be 'background', 'bodyguard', or 'Bulgarian'. In a function specifically about bigrams, using the full term 'bigram' makes the code instantly more readable.",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Rename to 'bug'",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'bigram'",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'backgram'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "bigramsfrequency",
              "replacement": "bigrams_frequency",
              "event": "bigramsfrequency",
              "hint": "This name needs some snake_case surgery. Stat!",
              "explanation": "This variable name is having an identity crisis - it can't decide if it wants to be camelCase or snake_case, so it chose neither! Consistency in naming style makes code much easier to read.",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to 'bigrams_frequency'",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'bi_grams_frequency'",
                  "correct": false
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'bigramsFrequency'",
                  "correct": false
                }
              ]
            }
          ],
          "startMessage": "Ah, the joys of cross-language developers! Anders and Nicolaus just transferred from the C# team and brought their naming conventions with them. They insist their style is \"perfectly readable\" and \"who cares about PEP 8 anyway?\"\n\nTheir code works, but it's like showing up to a Python conference wearing a tuxedo - technically dressed, but clearly missed the memo about the dress code. Can you help them blend in with the Python community?",
          "startReply": "Time for a Python style makeover!",
          "finalMessage": "Excellent work! You've successfully converted this code to follow Python's naming conventions. While the code would work either way, following the established style guidelines for a language makes your code more readable and maintainable for other Python developers. It's like learning the local customs when you visit a new country - it shows respect for the community and helps you integrate better!",
          "endReply": "Style guide conformance achieved!"
        },
        {
          "filename": "copy.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef copy(xs, ys, j, k, n):\n    \"\"\"Copy elements from ys to xs\n\n    Args:\n        xs - destination\n        ys - source\n        j - start index in xs\n        k - start index in ys\n        n - number of elements to copy\n    \"\"\"\n    for i in range(n):\n        xs[j+i] = ys[k+i]\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "xs",
              "replacement": "destination",
              "event": "xs",
              "explanation": "Ah, 'xs'! Is that a clothing size? An abbreviation for 'excess'? The documentation already calls it 'destination' - why not use that in the code too? Consistency between docs and code prevents confusion.",
              "hint": "The docstring is practically screaming the answer at you!",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to 'destination'",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'source'",
                  "correct": false
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'array'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "ys",
              "replacement": "source",
              "event": "ys",
              "hint": "The answer is right above you. No, literally, look up!",
              "explanation": "'ys'? Are we playing a game of 'Name That Variable: Vowel-Free Edition'? Again, the documentation already has a perfectly good name for this parameter.",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Rename to 'destination'",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'source'",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'array'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "j",
              "replacement": "dest_start",
              "event": "j",
              "hint": "j for... jumping? juggling? The docstring knows!",
              "explanation": "Single-letter variables like 'j' are perfect when you want your code to be as mysterious as possible. For everyone else, descriptive names like 'dest_start' make the code self-documenting.",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Rename to 'start'",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to 'dest_start'",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'end'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "k",
              "replacement": "src_start",
              "event": "k",
              "hint": "k is for... konsult the docstring!",
              "explanation": "The letter 'k' - saving valuable keystrokes since the invention of programming! But at what cost to readability? The few extra characters in 'src_start' make the code instantly more understandable.",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to 'src_start'",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'dest_start'",
                  "correct": false
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'src_end'",
                  "correct": false
                },
                {
                  "id": "bad-3",
                  "label": "Rename to 'dest_end'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "n",
              "replacement": "count",
              "event": "n",
              "hint": "n = noodles? narwhals? The docstring has the scoop!",
              "explanation": "'n' could stand for 'number', 'node', 'noodle'... The documentation says 'number of elements to copy', so why not use a name that actually conveys that meaning?",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to 'count'",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'src_len'",
                  "correct": false
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'len'",
                  "correct": false
                }
              ]
            }
          ],
          "startMessage": "Well, well, well... someone actually wrote documentation for their code! How quaint! \n\nBut wait - they used clear, descriptive terms in the docs, then proceeded to name their actual parameters like they were rationing letters during a keyboard shortage. It's like writing a detailed restaurant menu in beautiful prose, then serving the food in unmarked paper bags.\n\nLet's see if we can make the code as descriptive as its documentation, shall we?",
          "startReply": "Code should be as clear as its docs!",
          "finalMessage": "Excellent! You've transformed this function from cryptic to crystal clear. Now the code matches the quality of its documentation, making it immediately obvious what each parameter does without having to refer to the docstring. \n\nRemember: Good code is self-documenting. While comments and docstrings are valuable, they shouldn't be a crutch for poorly named variables. When your variable names tell the story clearly, your code becomes much easier to understand and maintain!",
          "endReply": "Documentation and code now in harmony!"
        },
        {
          "filename": "discount.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef is_discount_hunter(customer):\n    flag = True\n    for order in customer.orders:\n        flag2 = False\n        for item in order.items:\n            if item.product.discount > 0:\n                flag2 = True\n        flag = flag and flag2\n    return flag\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "flag",
              "replacement": "every_order_has_discounted_item",
              "event": "flag",
              "explanation": "Flags are for countries! Only!",
              "hint": "if flag? or if not flag? always difficult to decide...",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to something with both 'every_order' and 'discount' in the name",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'discounted'",
                  "correct": false
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'all_orders'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "flag2",
              "replacement": "has_discount",
              "event": "flag2",
              "explanation": "flag2? Is that the sequel to flag1? Coming soon to theaters near you! Numbered variables are like mystery boxes - exciting until you realize you have to open them to know what's inside.",
              "hint": "flag2 = ... or flag = ...?",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to 'has_discount'",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'no_discount'",
                  "correct": false
                }
              ]
            }
          ],
          "startMessage": "When you already have a variable called 'flag' and need another one, do you go with:\nA) flag and flag2\nB) flag and flag1\nC) flag1 and flag2\nD) Your option...\n\nOur developer chose option A!",
          "startReply": "Option D, obviously!",
          "finalMessage": "No more boolean guessing game in the code!\nNow anyone reading this function can understand its purpose at a glance: it checks if a customer only buys orders that contain at least one discounted item.\nDescriptive variable names make code tell a story, not pose a riddle!",
          "endReply": "ready_for_next_level = True"
        },
        {
          "filename": "board.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef initialization(board_json):\n    n = board_json['size']\n    board = creating_board(n, n)\n    board_reader(board_json, board)\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "n",
              "replacement": "board_size",
              "event": "n",
              "hint": "nitrogen? narnia? nirvana?",
              "explanation": "Ah, the mysterious 'n'! Is it a secret agent? The 14th letter of the alphabet? Or perhaps... the size of the board? Single-letter variables are like secret codes that only the original developer understands.",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to 'board_size'",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Rename to 'size'",
                  "correct": false
                },
                {
                  "id": "bad-2",
                  "label": "Rename to 'dimension'",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "initialization",
              "replacement": "initialize_board",
              "event": "initialization",
              "hint": "Functions DO things!",
              "explanation": "Functions should be verbs because they DO things! 'initialization' is the noun form - like saying 'swimming' instead of 'swim'. Your functions should sound like commands: 'create', 'calculate', 'destroy', not 'creation', 'calculation', 'destruction'.",
              "options": [
                {
                  "id": "good",
                  "label": "Rename to initialize_board",
                  "correct": true
                },
                {
                  "id": "bad-1",
                  "label": "Rename to initializing_board",
                  "correct": false
                },
                {
                  "id": "bad-2",
                  "label": "Rename to board_initializer",
                  "correct": false
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "creating_board",
              "replacement": "create_board",
              "event": "creating_board",
              "hint": "building, running, processing — are nouns!",
              "explanation": "'creating_board' sounds like you're narrating what you're doing: 'I am creating board now'. Function names should be direct commands: 'create_board!' It's more efficient and follows standard conventions.",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Rename to board_creation",
                  "correct": false
                },
                {
                  "id": "bad-2",
                  "label": "Rename to board_creator",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to create_board",
                  "correct": true
                }
              ]
            },
            {
              "type": "replace-span",
              "clickable": "board_reader",
              "replacement": "read_board",
              "event": "board_reader",
              "hint": "Writer, reader, manager — are nouns!",
              "explanation": "'board_reader' sounds like a job title, not an action. Is it a person who reads boards professionally? Functions should be verbs that describe the action they perform.",
              "options": [
                {
                  "id": "bad-1",
                  "label": "Rename to reading_board",
                  "correct": false
                },
                {
                  "id": "good",
                  "label": "Rename to read_board",
                  "correct": true
                },
                {
                  "id": "bad-2",
                  "label": "Rename to board_read",
                  "correct": false
                }
              ]
            }
          ],
          "startMessage": "Your colleague, who apparently skipped the \"Parts of Speech\" day in English class, has written some board game initialization code.\n\nThey proudly explained: \"It is simple! The 'initialization' consists of 'creating a board' and filling it with the 'board_reader'!\"\n\nTime to teach them the sacred rule of naming: functions — verbs, variables — nouns.",
          "startReply": "Let me fix these names...",
          "finalMessage": "Excellent work! You've transformed these function and variable names to follow proper naming conventions. Functions are now verbs (actions) and variables are nouns (things), making the code much more intuitive to read.\n\nThis naming pattern creates a natural language-like flow in your code: \"initialize_board takes a board_size and uses it to create_board and read_board.\" It reads almost like a sentence, which is exactly what good code should do!",
          "endReply": "Grammar fixed!"
        },
        {
          "filename": "final.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef InstructionParser(i):\n    Instructions = []\n    F = False\n    for l in i.splitlines():\n        if l.startswith(\"BEGIN\"):\n            F = True\n        if not F:\n            continue\n        if l.startswith(\"END\"):\n            F = False\n        elif l.startswith(\"replace \"):\n            rest = l[8:]\n            old, new = rest.split(\" with \")\n            Instructions.append((\"replace\", old, new))\n        elif l.startswith(\"add \"):\n            rest = l[4:]\n            Instructions.append((\"add\", rest))    \n        else:\n            raise Exception(\"Unknown instruction in line: \" + l)\n    return Instructions\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "InstructionParser",
              "replacement": "parse_instructions",
              "event": "InstructionParser",
              "explanation": "CamelCase function names in Python? That's like wearing a tuxedo to a beach party. Python has its own dress code (PEP 8), and it strongly recommends snake_case for functions. Also, functions should be verbs because they DO things - they're not just sitting around being nouns.",
              "hint": "CamelCase in Python? And it's not even a verb! Double whammy!"
            },
            {
              "type": "replace-span",
              "clickable": "Instructions",
              "replacement": "instructions",
              "event": "Instructions",
              "explanation": "Why is 'Instructions' capitalized? Is it royalty? A proper noun? The beginning of a sentence? In Python, variable names should be snake_case and lowercase unless they're constants (which this definitely isn't).",
              "hint": "Why is this variable SHOUTING its first letter? Royalty?"
            },
            {
              "type": "replace-span",
              "clickable": "F",
              "replacement": "inside_begin_end",
              "event": "F",
              "explanation": "Ah, the enigmatic 'F'! Is it paying respects? A grade? The sixth letter of the alphabet? Single-letter variables are like secret codes that only the original developer understands - and sometimes not even them after a few months.",
              "hint": "F = Fahrenheit? Failure? Friday? Press F to pay respects?"
            },
            {
              "type": "replace-span",
              "clickable": "l",
              "replacement": "line",
              "event": "l",
              "explanation": "The letter 'l' is particularly problematic as a variable name because in many fonts it looks identical to the number '1'. It's like setting a trap for the next developer (or yourself in 3 months).",
              "hint": "Is that an 'l', a '1', or an 'I'? Font roulette!"
            },
            {
              "type": "replace-span",
              "clickable": "i",
              "replacement": "instructions_text",
              "event": "i",
              "explanation": "The lonely 'i' parameter! Is it an index? An iterator? An imaginary number? When parameters are the entry point to your function, they deserve names that clearly explain what they contain.",
              "hint": "i = index? iterator? imaginary number? iPhone?"
            },
            {
              "type": "replace-span",
              "clickable": "4:",
              "replacement": "len(\"add \"):",
              "event": "4",
              "explanation": "Magic numbers like '4' are like mysterious ingredients in a recipe. 'Add a pinch of 4' - but why 4? What does it represent? Using 'len(\"add \")' makes it immediately clear you're skipping past a command prefix.",
              "hint": "Why 4? The answer is right in front of you... literally!"
            },
            {
              "type": "replace-span",
              "clickable": "8:",
              "replacement": "len(\"replace \"):",
              "event": "8",
              "explanation": "Another magic number! '8' is the lucky number in some cultures, but in code, unexplained numbers are just bad luck waiting to happen. What if the command syntax changes? You'd have to hunt down all these hardcoded values.",
              "hint": "8 is lucky in some cultures, unlucky in your code. Count the letters!"
            }
          ],
          "startMessage": "BEHOLD! I have crafted the most exquisite piece of code known to humanity! It's so perfect that it probably doesn't even need electricity to run - the sheer elegance of its logic could power a small city.\n\nAccording to our tedious team process, someone needs to review it. But let's be honest - this is just a formality. Simply approve it and we can all go home early!",
          "startReply": "Perfect!",
          "finalMessage": "Congratulations! You've transformed this \"perfect\" code into something actually worthy of approval. \n\nYou've applied all the naming best practices we've covered:\n1. Using snake_case for Python functions and variables\n2. Making function names verbs that describe their action\n3. Using descriptive names instead of single letters or abbreviations\n4. Replacing magic numbers with self-documenting expressions\n\nRemember: Code isn't just for computers to execute - it's for humans to read, understand, and maintain. Good naming is the foundation of readable code, and readable code is the foundation of maintainable software.\n\nYou've completed the naming challenges! Your future teammates thank you in advance for your clear, descriptive naming practices.",
          "endReply": "Is it a promotion?"
        }
      ],
      "inDevelopment": false
    },
    {
      "name": "Pythonic",
      "levels": [
        {
          "filename": "sum.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef print_sum_and_min(values):\n"
            },
            {
              "type": "replace",
              "text": "    sum_all = 0\n    for i in values:\n        sum_all += i\n",
              "replacement": "    sum_all = sum(values)\n",
              "event": "sum_loop",
              "explanation": "Why use an abacus when you have a calculator? Python's sum() is faster and less error-prone.",
              "hint": "Why build a calculator when there's one in your pocket?"
            },
            {
              "type": "replace",
              "text": "    min_value = values[0]\n    for v in values[1:]:\n        if v < min_value:\n            min_value = v\n",
              "replacement": "    min_value = min(values)\n",
              "event": "min_loop",
              "explanation": "Manual min-finding is dangerous and verbose. Python's min() is safer and cleaner.",
              "hint": "Finding minimums manually? What is this, the stone age?"
            },
            {
              "type": "text",
              "text": "    print(f\"sum: {sum_all}, min: {min_value}\")\n"
            }
          ],
          "startMessage": "Ah, I see your colleague is a fan of \"artisanal, hand-crafted loops\" - painstakingly constructing each calculation from scratch like it's 1995!\n\nThey probably also churn their own butter and forge their own paperclips. Let's introduce them to revolutionary concept of \"built-in functions\" that Python has had since... forever.",
          "startReply": "Let's modernize!",
          "finalMessage": "Excellent! Pythonic code!\n\nPython's built-in functions make your code more readable, concise, and often faster.\nRemember: \"Flat is better than nested\" and \"Simple is better than complex\" - core principles from the Zen of Python.",
          "endReply": "Built-ins for the win!"
        },
        {
          "filename": "csv_processing.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef list_to_csv(nums):\n"
            },
            {
              "type": "replace",
              "text": "    csv = \"\"\n    for n in nums:\n        csv += str(n) + \",\"\n    if csv.endswith(\",\"):\n        csv = csv[:-1]\n    return csv\n",
              "replacement": "    return \",\".join(str(n) for n in nums)\n",
              "event": "csv_join",
              "explanation": "String concatenation in loops is inefficient. join() is faster and handles edge cases.",
              "hint": "Concatenating strings in a loop? That's so 1990s!"
            },
            {
              "type": "text",
              "text": "\ndef count_zeros(values):\n"
            },
            {
              "type": "replace",
              "text": "    count = 0\n    for v in values:\n        if v == 0:\n            count += 1\n    return count\n",
              "replacement": "    return sum(1 for v in values if v == 0)\n",
              "event": "count_zeros",
              "explanation": "Generator expressions are elegant and efficient. Count zeros without the loop bloat.",
              "hint": "Why count manually when Python can do the math for you?"
            },
            {
              "type": "text",
              "text": "\ndef uppercase_file(filename):\n"
            },
            {
              "type": "replace",
              "text": "    file_obj = open(filename, 'r', encoding='utf-8')\n    big_text = file_obj.read().upper()\n    file_obj.close()\n    return big_text\n",
              "replacement": "    with open(filename, 'r', encoding='utf-8') as f:\n        return f.read().upper()\n",
              "event": "with_open",
              "explanation": "The 'with' statement auto-closes files, even after exceptions. No more resource leaks!",
              "hint": "Forgetting to close files? There's a 'with' for that!"
            }
          ],
          "startMessage": "Oh look, another \"for loop enthusiast\" who never met a loop they didn't like! \n\nThis code has more unnecessary loops than a roller coaster factory. It's like watching someone dig a hole with a spoon when there's a perfectly good shovel nearby. Let's introduce them to some Pythonic constructs that can save both keystrokes and sanity!",
          "startReply": "Let's Pythonize it!",
          "finalMessage": "Bravo! You've transformed verbose code into elegant, Pythonic expressions.\n\nPython's powerful constructs (join, generator expressions, context managers) aren't just shortcuts - they're the idiomatic way to write Python. Remember: \"There should be one obvious way to do it.\"",
          "endReply": "Pythonic elegance achieved!"
        },
        {
          "filename": "search.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef contains(text, pattern):\n"
            },
            {
              "type": "replace",
              "text": "    pattern_len = len(pattern)\n    for i in range(len(text)):\n        if text[i:i+pattern_len] == pattern:\n            return True\n    return False\n",
              "replacement": "    # Do we really need this function?!\n    return pattern in text\n",
              "event": "in_operator",
              "explanation": "Why reinvent the wheel? The 'in' operator is concise, optimized, and already built-in.",
              "hint": "Python has a built-in way to check string containment. No loops needed!"
            }
          ],
          "startMessage": "Wait a minute... didn't we just fix a 'contains' function in another file? \n\nOh, I see what happened. Your colleague fixed the bug in the previous version but still didn't realize that Python has this magical thing called the 'in' operator. It's like they fixed a leaky boat with duct tape when there was a perfectly good yacht available!\n\nLet's put this poor function out of its misery once and for all.",
          "startReply": "Use built-ins!",
          "finalMessage": "Perfect! You've replaced a manual algorithm with Python's built-in 'in' operator.\n\nThis is classic Pythonic code - using built-in features instead of reinventing them. The 'in' operator is concise, readable, efficient, and less error-prone.",
          "endReply": "Built-in operators FTW!"
        },
        {
          "filename": "unescape.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef unescape(text):\n"
            },
            {
              "type": "replace",
              "text": "    result = \"\"\n    escaping = False\n    for char in text:\n        if escaping:\n            if char == 'n':\n                result += '\\n'\n            elif char == 't':\n                result += '\\t'\n            elif char == '\\\\':\n                result += '\\\\'\n            # ... other escape sequences here...\n            else:\n                result += '\\\\' + char  # unknown escape — keep as-is\n            escaping = False\n        elif char == '\\\\':\n            escaping = True\n        else:\n            result += char\n    return result\n",
              "replacement": "    # Python rule 101: everything is already implemented in some standard function!\n    return text.encode('utf-8').decode('unicode_escape')\n",
              "event": "encode_decode",
              "explanation": "20 lines of manual character parsing versus a single line of built-in functionality! This is like building your own calculator when there's one right there in your pocket. Python's encoding/decoding system already handles all escape sequences, including ones your manual version doesn't even support!",
              "hint": "Unescaping strings is such a common operation that Python must have a built-in way to handle it. Think about string encoding and decoding..."
            }
          ],
          "startMessage": "Unescape function? Again?! \n\nFirst we fixed the terrible variable names, and now we're back to fix the implementation itself. It's like your colleague is determined to solve problems that Python already solved years ago!\n\nThis manual character-by-character parsing is impressive in its thoroughness... and completely unnecessary. Let's see if we can replace this 20-line state machine with something more... Pythonic.",
          "startReply": "There must be a built-in way to do this!",
          "finalMessage": "Excellent! You've replaced a complex manual implementation with Python's built-in functionality.\n\nThis is a perfect example of the \"batteries included\" philosophy of Python. Before implementing any non-trivial functionality, it's always worth checking if Python's standard library already has a solution. In this case, the encode/decode approach:\n\n1. Is much more concise (1 line vs 20)\n2. Handles all standard escape sequences, not just the few explicitly coded\n3. Is likely more efficient as it's implemented in C\n4. Has been thoroughly tested by the Python community\n\nRemember: \"There should be one-- and preferably only one --obvious way to do it.\" In Python, the obvious way is usually the built-in way!",
          "endReply": "Batteries included indeed!"
        },
        {
          "filename": "dot_product.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef dot_product(a, b):\n    result = 0\n"
            },
            {
              "type": "replace",
              "text": "    for i in range(len(a)):\n        result += a[i] * b[i]\n    return result\n",
              "replacement": "    for x, y in zip(a, b):\n        result += x * y\n    return result\n",
              "event": "iinrange",
              "clickable": "i in range",
              "explanation": "Avoid indexes! Use zip for parallel iteration.",
              "hint": "Two lists walk into a bar… together."
            },
            {
              "type": "replace-span",
              "clickable": "a",
              "replacement": "vector1",
              "event": "a",
              "hint": "a?",
              "explanation": "Single letters in the function signature?"
            },
            {
              "type": "replace-span",
              "clickable": "b",
              "replacement": "vector2",
              "event": "b",
              "hint": "b?",
              "explanation": "dot_product of two vectors. Not it is perfectly clear!"
            }
          ],
          "startMessage": "Rumour has it this function was ported from punch-card code in Fortran.",
          "startReply": "Hold my coffee!",
          "finalMessage": "Much cleaner now! But not enough...",
          "endReply": "Not enough?!"
        },
        {
          "filename": "dot_product2.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef dot_product(vector1, vector2):\n"
            },
            {
              "type": "replace",
              "text": "    result = 0\n    for x, y in zip(vector1, vector2):\n        result += x * y\n",
              "replacement": "    return sum(x*y for (x, y) in zip(vector1, vector2))\n",
              "event": "id",
              "explanation": "Often you can avoid not only indexes but also for loops!",
              "hint": "loop?"
            }
          ],
          "startMessage": "Maybe one final fix...",
          "finalMessage": "Perfect! `zip` pairs elements safely, reads like English,\nand kicks index acrobatics to the curb.",
          "endReply": "Zip-zap, done!"
        },
        {
          "filename": "unique_words.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef unique_words(text, seen=set()):\n    \"\"\"Return unique words we haven't seen before (case-insensitive).\"\"\"\n"
            },
            {
              "type": "replace-on",
              "event": "md",
              "text": "",
              "replacement": "    if seen is None:\n        seen = set()\n"
            },
            {
              "type": "text",
              "text": "    words = text.lower().split()\n    for word in words:\n        if list(seen).count(word) == 0:\n            seen.add(word)\n            yield word\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "list(seen).count(word) == 0",
              "replacement": "not (word in seen)",
              "event": "listseencountword0"
            },
            {
              "type": "replace-span",
              "clickable": "not (word in seen)",
              "replacement": "word not in seen",
              "event": "notwordinseen"
            },
            {
              "type": "replace-span",
              "clickable": "seen=set()",
              "replacement": "seen=None",
              "event": "md",
              "explanation": "Default arguments are evaluated once — so this cheerful little set() is shared across *every* call. Like a clingy ex, it never forgets.",
              "hint": "If your function remembers things you didn't tell it to… it's haunted."
            }
          ],
          "startMessage": "Déjà-vu detection gone rogue!\nBecause the function’s default `set()` is shared across calls, words remembered from round #1 vanish in round #2.\nLet’s stop that silent memory leak before it confuses the next intern.",
          "startReply": "Let’s make it truly unique!",
          "finalMessage": "Now that we’ve exorcised the memory-leaking default,\nunique_words behaves like a normal function — not a long-term surveillance device.\nFresh state per call, zero ghosts in the machine.\nPythonic and private, just the way we like it.",
          "endReply": "Fresh every time!"
        },
        {
          "filename": "report_errors.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef report_errors(lines):\n"
            },
            {
              "type": "replace",
              "text": "    for i in range(len(lines)):\n        line = lines[i]\n",
              "replacement": "    for i, line in enumerate(lines):\n",
              "event": "id",
              "explanation": "Manual indexing is fragile and clunky. enumerate() gives you the index and the item in one clean shot.",
              "hint": "Let Python count for you — it’s good at it."
            },
            {
              "type": "text",
              "text": "        if \"ERROR\" in line:\n"
            },
            {
              "type": "replace",
              "text": "            print(\"Line \" + str(i + 1) + \": \" + line)\n",
              "replacement": "            print(f\"Line {i+1}: {line}\")\n",
              "event": "Linestri1line",
              "clickable": "Line \" + str(i + 1) + \": \" + line",
              "explanation": "f-strings are faster, cleaner, and easier to read than string concatenation.",
              "hint": "Why concatenate when you can interpolate?"
            }
          ],
          "startMessage": "This function works... but feels like it time-traveled from 2002.\nLet’s give it a Pythonic glow-up!",
          "startReply": "Hold my semicolon",
          "finalMessage": "P-p-p... Pythonic!",
          "endReply": "Formatted and fabulous."
        },
        {
          "filename": "bag_of_words.py",
          "blocks": [
            {
              "type": "text",
              "text": "\ndef bag_of_words(text, stop_words=[]):\n"
            },
            {
              "type": "replace-on",
              "event": "md",
              "text": "",
              "replacement": "    if stop_words is None:\n        stop_words = []\n"
            },
            {
              "type": "text",
              "text": "    words = text.lower().split()\n    dict = {}\n"
            },
            {
              "type": "replace",
              "text": "    for i in range(len(words)):\n        word = words[i]\n",
              "replacement": "    for word in words:\n",
              "event": "loop",
              "clickable": "i in range",
              "explanation": "range(len()) is a 1990s dance move. Loop directly and stay readable.",
              "hint": "Drop the index juggling act."
            },
            {
              "type": "text",
              "text": "        if word in stop_words:\n            continue\n        if word in dict:\n            dict[word] += 1\n        else:\n            dict[word] = 1\n"
            },
            {
              "type": "replace",
              "text": "    result = []\n    for k in dict.keys():\n        result.append((k, dict[k]))\n    return result\n",
              "replacement": "    return list(dict.items())\n",
              "event": "id"
            },
            {
              "type": "replace-span",
              "clickable": "stop_words=[]",
              "replacement": "stop_words=None",
              "event": "md",
              "explanation": "Mutable defaults are time bombs. Much safer to avoid them totally",
              "hint": "Look carefully at the first line!"
            },
            {
              "type": "replace-span",
              "clickable": "dict",
              "replacement": "frequencies",
              "event": "rename",
              "explanation": "Shadowing built-ins starts turf wars. Give the poor 'dict' its name back.",
              "hint": "Why pick a fight with a core type?"
            }
          ],
          "startMessage": "Grab your hazmat suit, Junior — this function comes with its own built-in foot-guns:\nClick fast before someone deploys it to production Slack bots.",
          "startReply": "Deploy the fixes!",
          "finalMessage": "Boom! No more shared stop-word ghosts, no more hijacked 'dict', and the loop finally speaks Python.\nRemember: safe defaults, respect the built-ins, and iterate like a local — your future self will thank you.",
          "endReply": "Clean and counting!"
        },
        {
          "filename": "student_scores.py",
          "blocks": [
            {
              "type": "text",
              "text": "def analyze_scores(data):\n    result = {}\n"
            },
            {
              "type": "replace",
              "text": "    for i in range(0, len(data)):\n        name = data[i][0]\n        scores = data[i][1]\n",
              "replacement": "    for name, scores in data:\n",
              "event": "foriinrange0lendata",
              "clickable": "for i in range(0, len(data))",
              "explanation": "No indices! Let the data tell the story, not the loop counter.",
              "hint": "Indices?"
            },
            {
              "type": "replace",
              "text": "        total = 0\n        for j in range(0, len(scores)):\n            total = total + scores[j]\n",
              "replacement": "",
              "event": "loop",
              "clickable": "for j in range(0, len(scores))",
              "explanation": "Let Python do the math.",
              "hint": "Built-ins... Remember them?"
            },
            {
              "type": "replace-on",
              "text": "        avg = total / len(scores)\n",
              "replacement": "        avg = sum(scores) / len(scores)\n",
              "event": "loop"
            },
            {
              "type": "text",
              "text": "        result[name] = avg\n\n"
            },
            {
              "type": "replace",
              "text": "    keys = list(result.keys())\n    keys.sort()\n    for i in range(0, len(keys)):\n        name = keys[i]\n",
              "replacement": "    for name in sorted(result):\n",
              "event": "foriinrange0lenkeys",
              "clickable": "for i in range(0, len(keys))",
              "explanation": "for name in `sorted(result)` and -3 lines of code.",
              "hint": "Sorted loops don’t require pre-sorting the keys."
            },
            {
              "type": "text",
              "text": "        avg = result[name]\n"
            },
            {
              "type": "replace",
              "text": "        print(name + \": \" + str(round(avg, 2)))\n",
              "replacement": "        print(f\"{name}: {round(avg, 2)}\")\n",
              "event": "namestr",
              "clickable": "name + \": \" + str",
              "explanation": "f-strings. Remember them?",
              "hint": "a, b, c, d, e, ... What's next?"
            },
            {
              "type": "text",
              "text": "\n"
            },
            {
              "type": "replace",
              "text": "    top = None\n    top_score = -1\n    for k in result:\n        if result[k] > top_score:\n            top_score = result[k]\n            top = k\n",
              "replacement": "    top, top_score = max(result.items(), key=lambda item: item[1])\n",
              "event": "forkinresult",
              "clickable": "for k in result:",
              "explanation": "One more built-in! max(..., key=...) with lambda!",
              "hint": "Stop reinventing wheels!"
            },
            {
              "type": "text",
              "text": "\n"
            },
            {
              "type": "replace",
              "text": "    print(\"Top student is \" + top + \" with score \" + str(top_score))\n",
              "replacement": "    print(f\"Top student is {top} with score {top_score}\")\n",
              "event": "Topstudentistopwiths",
              "clickable": "Top student is \" + top + \" with score \" + str(top_score)",
              "explanation": "f-strings again — they handle variables and formatting gracefully.",
              "hint": "You’re better than chained string concatenation."
            },
            {
              "type": "replace-span",
              "clickable": "data",
              "replacement": "student_scores",
              "event": "data",
              "explanation": "You say data, when you don't know what else to say",
              "hint": "data is everywhere!"
            }
          ],
          "startMessage": "This code technically works... but so does assembling IKEA furniture with your forehead.\nManual indexing, verbose accumulation, and enough string glue to open a kindergarten.\nLet’s apply some Pythonic polish before someone copy-pastes this into production.",
          "startReply": "Sharpening the scalpel...",
          "finalMessage": "Now *that* looks like Python. Almost...",
          "endReply": "Almost?!"
        },
        {
          "filename": "student_scores2.py",
          "blocks": [
            {
              "type": "text",
              "text": "def analyze_scores(student_scores):\n"
            },
            {
              "type": "replace",
              "text": "    result = {}\n    for name, scores in student_scores:\n        avg = sum(scores) / len(scores)\n        result[name] = avg\n",
              "replacement": "    result = {\n        name: sum(scores) / len(scores)\n        for name, scores in data\n    }\n",
              "event": "fornamescoresinstude",
              "clickable": "for name, scores in student_scores",
              "explanation": "This loop just builds a dictionary. A comprehension does the same job with less ceremony and more clarity.",
              "hint": "Loops are COMPREHENSIVE! :winking:"
            },
            {
              "type": "text",
              "text": "    for name in sorted(result):\n        avg = result[name]\n        print(f\"{name}: {round(avg, 2)}\")\n\n    top, top_score = max(result.items(), key=lambda item: item[1])\n    print(f\"Top student is {top} with score {top_score}\")\n\n"
            }
          ],
          "startMessage": "Maybe one more little fix",
          "finalMessage": "No more index wrangling, no more glue gun print statements,\nand no more DIY loops. You turned clunky code into a clean, declarative joyride.",
          "endReply": "I'm Pythonic guru!"
        }
      ],
      "inDevelopment": false
    },
    {
      "name": "Decomposition",
      "levels": [
        {
          "filename": "scores.py",
          "blocks": [
            {
              "type": "replace-on",
              "event": [
                "block1",
                "block2",
                "block3"
              ],
              "text": "",
              "replacement": "def some_duplication(scores):\n    res = []\n    for score in scores:\n        if score < 0:\n            score = 0\n        elif score > 100:\n            score = 100\n        res.append(score)\n    return res\n"
            },
            {
              "type": "replace-span",
              "clickable": "some_duplication",
              "replacement": "clamp_scores",
              "event": "some_duplication",
              "explanation": "Okay, now it's finally clear what this function is",
              "hint": "Time to get rid of temporary names!"
            },
            {
              "type": "text",
              "text": "\ndef process_exam_scores(raw_scores):\n"
            },
            {
              "type": "replace",
              "text": "    math_scores = []\n    for score in raw_scores['math']:\n        if score < 0:\n            score = 0\n        elif score > 100:\n            score = 100\n        math_scores.append(score)\n",
              "replacement": "    math_scores = some_duplication(raw_scores['math'])\n",
              "event": "block1",
              "explanation": "This code is duplicating!",
              "hint": "math... programmers don't need math!"
            },
            {
              "type": "replace",
              "text": "    science_scores = []\n    for score in raw_scores['science']:\n        if score < 0:\n            score = 0\n        elif score > 100:\n            score = 100\n        science_scores.append(score)\n",
              "replacement": "    science_scores = some_duplication(raw_scores['science'])\n",
              "event": "block2",
              "explanation": "D-D-Duplication!",
              "hint": "science... the only science I like is Computer Science!"
            },
            {
              "type": "replace",
              "text": "    history_scores = []\n    for score in raw_scores['history']:\n        if score < 0:\n            score = 0\n        elif score > 100:\n            score = 100\n        history_scores.append(score)\n",
              "replacement": "    history_scores = some_duplication(raw_scores['history'])\n",
              "event": "block3",
              "explanation": "DRY (Don't Repeat Yourself) isn't just about saving keystrokes - it's about having a single source of truth. Now if the normalization logic changes, you only need to update it in one place!",
              "hint": "I hope they mean git history?"
            },
            {
              "type": "text",
              "text": "    # ...\n"
            }
          ],
          "startMessage": "Welcome back, Junior! Today's code review is from our intern who seems to have a copy-paste addiction.\n\nIt seems, he forces us to use copy-paste a lot in our code review notes!",
          "startReply": "Oh... Interns...",
          "finalMessage": "Good start! What is next?",
          "endReply": "Next?!"
        },
        {
          "filename": "scores_v2.py",
          "blocks": [
            {
              "type": "replace-on",
              "event": "clamp",
              "text": "",
              "replacement": "def clamp_score(score_val, min_val, max_val):\n  return min(max_val, max(min_val, score_val))\n\n"
            },
            {
              "type": "text",
              "text": "def clamp_scores(scores):\n    res = []\n    for score in scores:\n"
            },
            {
              "type": "replace",
              "text": "      if score < 0:\n        score = 0\n      elif score > 100:\n        score = 100\n      res.append(score)\n",
              "replacement": "      res.append(clamp_score(score, 0, 100))\n",
              "event": "clamp",
              "explanation": "Sometimes you extract function not because of duplication!",
              "hint": "We just put score value in certain bound..."
            },
            {
              "type": "text",
              "text": "    return res\n\ndef process_exam_scores(raw_scores):\n    math_scores = clamp_scores(raw_scores['math'])\n    science_scores = clamp_scores(raw_scores['science'])\n    history_scores = clamp_scores(raw_scores['history'])\n    # ...\n"
            },
            {
              "type": "replace-span",
              "clickable": "clamp_score",
              "replacement": "clamp",
              "event": "clamp_score",
              "explanation": "Nothing special in scores. Any number can be clamped",
              "hint": "Not only scores deserves to be clamped!"
            },
            {
              "type": "replace-span",
              "clickable": "score_val",
              "replacement": "value",
              "event": "score_val",
              "explanation": "Yes, not just score — any value goes!",
              "hint": "What is so special in scores?"
            }
          ],
          "startMessage": "I clearly can see some helpful primitive here, valuable not only for scores processing.",
          "startReply": "Primitive?!",
          "finalMessage": "No we can move this clamp function to our math library and use it everywhere!\n\nBTW, are you finished here?",
          "endReply": "Not yet!"
        },
        {
          "filename": "scores_v3.py",
          "blocks": [
            {
              "type": "text",
              "text": "def clamp_scores(scores):\n"
            },
            {
              "type": "replace",
              "text": "    res = []\n    for score in scores:\n      res.append(clamp_score(score, 0, 100))\n    return res\n",
              "replacement": "    return [clamp_score(score, 0, 100) for score in scores]\n",
              "event": "id",
              "explanation": "List comprehensions are faster, cleaner, and easier to read than loops.",
              "hint": "Loops are for the weak!"
            },
            {
              "type": "text",
              "text": "\ndef process_exam_scores(raw_scores):\n"
            },
            {
              "type": "replace",
              "text": "    math_scores = clamp_scores(raw_scores['math'])\n    science_scores = clamp_scores(raw_scores['science'])\n    history_scores = clamp_scores(raw_scores['history'])\n\n    add_to_report('math', math_scores)\n    add_to_report('science', science_scores)\n    add_to_report('history', history_scores)\n",
              "replacement": "    for subject in ['math', 'science', 'history']:\n        subject_scores = clamp_scores(raw_scores[subject])\n        add_to_report(subject, subject_scores)\n",
              "event": "id-1",
              "explanation": "Join score processing and reporting into one operation and put it in a loop. Much cleaner now!",
              "hint": "Look, each topic is handled in the same way."
            }
          ],
          "startMessage": "Okay, what can you fix here?",
          "finalMessage": "Wow, not an intern-looking-code anymore!",
          "endReply": "I like it too, thanks!"
        },
        {
          "filename": "convey.py",
          "blocks": [
            {
              "type": "text",
              "text": "from collections import Counter\n\n"
            },
            {
              "type": "replace-on",
              "event": "point",
              "text": "",
              "replacement": "Point = tuple[int,int]\n\n"
            },
            {
              "type": "replace-on",
              "event": "will_be_alive",
              "text": "",
              "replacement": "def will_live(alive_neighbors_count: int, is_alive: bool) -> bool:\n    return alive_neighbors_count == 3 or (alive_neighbors_count == 2 and is_alive)\n\n"
            },
            {
              "type": "replace-on",
              "event": "iter",
              "text": "",
              "replacement": "def neighbors(x: int, y: int) -> Iterator[Point]:\n    for dx in (-1, 0, 1):\n        for dy in (-1, 0, 1):\n            if dx or dy:\n                yield (x + dx, y + dy)\n\n"
            },
            {
              "type": "text",
              "text": "def game_of_life_step(alive: set[tuple[int, int]]) -> set[tuple[int, int]]:\n    nbrs = Counter()\n    for x, y in alive:\n"
            },
            {
              "type": "replace",
              "text": "        for dx in (-1, 0, 1):\n            for dy in (-1, 0, 1):\n                if dx or dy:\n                    pos = (x + dx, y + dy)\n",
              "replacement": "        for pos in neighbors(x, y):\n",
              "event": "iter",
              "hint": "Can a specific, repeating calculation be put into its own helper?",
              "explanation": "Extracting a specific task into its own function makes the main code clearer. Now, your loop is not a mystery anymore!"
            },
            {
              "type": "replace-on",
              "text": "                    nbrs[pos] += 1\n",
              "replacement": "          nbrs[pos] += 1\n",
              "event": "iter"
            },
            {
              "type": "text",
              "text": "\n"
            },
            {
              "type": "replace",
              "text": "    new_alive: set[tuple[int, int]] = set()\n    for cell, count in nbrs.items():\n        if count == 3 or (count == 2 and cell in alive):\n            new_alive.add(cell)\n    return new_alive\n",
              "replacement": "    return {cell for cell, count in nbrs.items() \n        if count == 3 or (count == 2 and cell in alive)}\n",
              "event": "forcellcountin",
              "clickable": "for cell, count in",
              "hint": "Is there a more direct way to build a collection based on a condition?",
              "explanation": "Why take extra steps? Set comprehensions let you build new sets in one clear line!"
            },
            {
              "type": "replace-span",
              "clickable": "tuple[int, int]",
              "replacement": "Point",
              "event": "point",
              "hint": "Some complex types could have a more descriptive name",
              "explanation": "Nice. This type alias really made code cleaner!"
            },
            {
              "type": "replace-span",
              "clickable": "nbrs",
              "replacement": "neighbor_counts",
              "event": "nbrs",
              "hint": "Could this name be more rdbl?",
              "explanation": "Abbreviations in code? Bad idea! Readable names make your code a joy to read, not a puzzle."
            },
            {
              "type": "replace-span",
              "clickable": "count == 3 or (count == 2 and cell in alive)",
              "replacement": "will_live(count, cell in alive)",
              "event": "will_be_alive",
              "hint": "Complex bool expressions usually have some simple meaning",
              "explanation": "It's like giving a label to a mystery box!"
            }
          ],
          "startMessage": "Look at this 'Game of Life' implementation.\nIt's one giant function that does everything.\nIt's like reading a recipe where all the steps are mixed into a single sentence.",
          "startReply": "I'll untangle this.",
          "finalMessage": "By breaking the logic into smaller functions like `will_live` and `neighbors`, you made the code tell a story.",
          "endReply": "Ready to the next one!"
        },
        {
          "filename": "mergesort.py",
          "blocks": [
            {
              "type": "text",
              "text": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return\n"
            },
            {
              "type": "replace",
              "text": "    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n",
              "replacement": "    left, right = _split(arr)\n",
              "event": "extract-split",
              "explanation": "Splitting a list in-place isn’t that self-explanatory. Give it a name.",
              "hint": "That mid-slicing logic? It deserves its own home."
            },
            {
              "type": "text",
              "text": "    merge_sort(left)\n    merge_sort(right)\n"
            },
            {
              "type": "replace",
              "text": "    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            arr[k] = left[i]\n            i += 1\n        else:\n            arr[k] = right[j]\n            j += 1\n        k += 1\n    while i < len(left):\n        arr[k] = left[i]\n        i += 1\n        k += 1\n    while j < len(right):\n        arr[k] = right[j]\n        j += 1\n        k += 1\n",
              "replacement": "    _merge(arr, left, right)\n",
              "event": "extract-merge",
              "explanation": "That merge block was screaming to be its own function.",
              "hint": "That 20-line merge? Make it disappear."
            },
            {
              "type": "replace-on",
              "event": "extract-split",
              "text": "",
              "replacement": "\ndef _split(arr):\n    mid = len(arr) // 2\n    return arr[:mid], arr[mid:]\n"
            },
            {
              "type": "replace-on",
              "event": "extract-merge",
              "text": "",
              "replacement": "\ndef _merge(target, left, right):\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            target[k] = left[i]\n            i += 1\n        else:\n            target[k] = right[j]\n            j += 1\n        k += 1\n\n    while i < len(left):\n        target[k] = left[i]\n        i += 1\n        k += 1\n\n    while j < len(right):\n        target[k] = right[j]\n        j += 1\n        k += 1\n"
            }
          ],
          "startMessage": "This merge sort is allergic to functions. Let's break it down, one helper at a time!",
          "startReply": "Breaking things!",
          "finalMessage": "Now your merge sort reads like a story: split, sort, merge, done. Helpers make logic readable — and bugs easier to kill.",
          "endReply": "Split. Sorted. Merged."
        },
        {
          "filename": "mergesort_v2.py",
          "blocks": [
            {
              "type": "text",
              "text": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return\n    left, right = _split(arr)\n    merge_sort(left)\n    merge_sort(right)\n    _merge(arr, left, right)\n\ndef _split(arr):\n    mid = len(arr) // 2\n    return arr[:mid], arr[mid:]\n\ndef _merge(target, left, right):\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            target[k] = left[i]\n            i += 1\n        else:\n            target[k] = right[j]\n            j += 1\n        k += 1\n\n"
            },
            {
              "type": "replace",
              "text": "    while i < len(left):\n        target[k] = left[i]\n        i += 1\n        k += 1\n",
              "replacement": "    _copy_tail(target, k, left, i)\n",
              "event": "extract-copy-left",
              "explanation": "That loop looks familiar. Let’s abstract it.",
              "hint": "One line instead of three. Worth it."
            },
            {
              "type": "replace",
              "text": "    while j < len(right):\n        target[k] = right[j]\n        j += 1\n        k += 1\n",
              "replacement": "    _copy_tail(target, k, right, j)\n",
              "event": "extract-copy-right",
              "explanation": "Duplication is boring. Helpers are fun.",
              "hint": "Looks just like the other one, doesn’t it?"
            },
            {
              "type": "replace-on",
              "event": [
                "extract-copy-right",
                "extract-copy-left"
              ],
              "text": "",
              "replacement": "\ndef _copy_tail(dst, dst_index, src, src_index):\n    for value in src[src_index:]:\n        dst[dst_index] = value\n        dst_index += 1\n"
            }
          ],
          "startMessage": "This merge sort is allergic to functions. Let's break it down, one helper at a time!",
          "startReply": "Breaking things!",
          "finalMessage": "Now your merge sort reads like a story: split, sort, merge, done. Helpers make logic readable — and bugs easier to kill.",
          "endReply": "Split. Sorted. Merged."
        }
      ],
      "inDevelopment": false
    }
  ]
}