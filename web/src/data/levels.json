{
  "topics": [
    {
      "name": "Testing",
      "wisdoms": [
        {
          "id": "1",
          "text": "Поспешишь — QA-ев насмешишь!"
        },
        {
          "id": "2",
          "text": "Под лежачий прод бабло не течёт!"
        }
      ],
      "levels": [
        {
          "filename": "onboarding.py",
          "wisdoms": [
            "1",
            "2"
          ],
          "blocks": [
            {
              "type": "text",
              "text": "def foo():\n    print(42)\n\n"
            },
            {
              "type": "replace",
              "text": "def bar():\n    print(\"Hello bar!\")\n",
              "replacement": "def greet_user():\n    print(\"Hello\")\n",
              "event": "bar",
              "clickable": "bar",
              "explanation": "No Foos!"
            },
            {
              "type": "text",
              "text": "\n"
            },
            {
              "type": "replace",
              "text": "def BAD_CODE():\n    print(\"BAD\")\n",
              "replacement": "",
              "event": "BAD_CODE",
              "explanation": "Do not write bad code!"
            },
            {
              "type": "text",
              "text": "\n"
            },
            {
              "type": "replace-on",
              "text": "",
              "replacement": "def GOOD_CODE():\n    print(\"ABSOLUTELY GOOD CODE!\")\n",
              "event": "BAD_CODE"
            },
            {
              "type": "replace-span",
              "clickable": "foo",
              "replacement": "nonfoo",
              "event": "foo",
              "explanation": "no foos",
              "hint": "Look at foo!"
            },
            {
              "type": "text",
              "text": "\n"
            },
            {
              "type": "replace-span",
              "clickable": "42",
              "replacement": "the_answer",
              "event": "e42",
              "explanation": "no magic constants!",
              "hint": "42 = 6 * 8"
            }
          ],
          "startMessage": "This is a test level"
        }
      ]
    },
    {
      "name": "Naming",
      "wisdoms": [
        {
          "id": "naming-good-names",
          "text": "Use descriptive names that convey intent."
        },
        {
          "id": "no-abbr",
          "text": "Don't use abbreviations unless they are well-known."
        },
        {
          "id": "sign-is-doc",
          "text": "Function arguments are documentation. Use meaningful names!"
        }
      ],
      "levels": [
        {
          "filename": "onboarding.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef main():\n    BaD_VAriABLE_NAME = \"Hello!\"\n    print(BaD_VAriABLE_NAME)\n"
            },
            {
              "type": "replace-span",
              "clickable": "BaD_VAriABLE_NAME",
              "replacement": "greeting",
              "event": "BaD_VAriABLE_NAME",
              "explanation": "Much better! Variable names should be readable by humans, not just compilers with low standards.",
              "hint": "That variable name is begging for mercy. Click it before my eyes bleed!"
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "Welcome to the coding trenches, Junior! \nAccording to our team traditions (and manager's trust issues), you're not allowed to write code yet.\nYour sacred duty is to review your colleagues' masterpieces and fix \"small, insignificant details\" - you know, the ones that cause production outages at 3 AM.\n\nLet's start with something even you can't mess up. See that variable name that looks like someone fell asleep on their keyboard? Click to fix it before my eyes start bleeding!",
          "startReply": "I'll save your eyes!",
          "finalMessage": "Well done! Your journey to becoming slightly less junior has begun!",
          "endReply": "Bring on the next challenge!"
        },
        {
          "filename": "temperature.py",
          "wisdoms": [
            "no-abbr",
            "sign-is-doc"
          ],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef fmt_temp(idx, tt):\n    dnms = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    return \"Temperature for \" + dnms[idx] + \" is \" + str(tt) + \"° C\"\n"
            },
            {
              "type": "replace-span",
              "clickable": "idx",
              "replacement": "day_of_week",
              "event": "idx",
              "explanation": "Parameter names should tell a story, not play hide and seek with meaning. 'idx' saves keystrokes but costs clarity.",
              "hint": "Index of what?!"
            },
            {
              "type": "replace-span",
              "clickable": "tt",
              "replacement": "temperature",
              "event": "tt",
              "explanation": "Abbreviations save seconds typing but cost minutes of confusion. What does 'tt' even mean?",
              "hint": "Imagine that names are the only documentation on this function you have..."
            },
            {
              "type": "replace-span",
              "clickable": "dnms",
              "replacement": "day_names",
              "event": "dnms",
              "explanation": "Vowels aren't just decorative - they make words recognizable! 'dnms' looks like a typo.",
              "hint": "Variable lost its vowels. Perform vowel-donation surgery!"
            },
            {
              "type": "replace-span",
              "clickable": "fmt_temp",
              "replacement": "format_temperature",
              "event": "fmt_temp",
              "explanation": "'fmt_temp' could mean anything from formatting templates to fermenting tempeh.",
              "hint": "Imagine that function name is the only documentation on this function you have..."
            }
          ],
          "startMessage": "Time for some real work! Take a look at this cryptic masterpiece of your colleague and see if you can decipher what's happening without consulting ancient scrolls or summoning a code whisperer.\nLet's make this readable for mere mortals."
        },
        {
          "filename": "cells.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "def get(lst):\n    lst1 = []\n    for c in lst:\n        if c.is_empty: \n            lst1.Add(c.position)\n    return lst1\n\nlst = read_cells(\"cells.csv\")\nprint(get(lst))\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "get",
              "replacement": "get_empty_positions",
              "event": "get",
              "explanation": "The mysterious 'get' function! Get what? The name 'get_empty_positions' actually tells us what it returns.",
              "hint": "get... what?!"
            },
            {
              "type": "replace-span",
              "clickable": "lst1",
              "replacement": "empty_positions",
              "event": "lst1",
              "explanation": "lst1? Is this a sequel to lst? Variable names should tell a story, not just be numbered placeholders.",
              "hint": "List contains positions. Name it to reflect its purpose, not its sequence."
            },
            {
              "type": "replace-span",
              "clickable": "lst",
              "replacement": "cells",
              "event": "lst",
              "explanation": "Naming a list of cells 'lst' forces developers to guess. Descriptive names save brain cycles.",
              "hint": "This parameter has objects with 'is_empty' property. What are these objects?"
            },
            {
              "type": "replace-span",
              "clickable": "c",
              "replacement": "cell",
              "event": "c",
              "explanation": "Single-letter loop variables are mysterious characters never properly introduced. Clarity beats brevity.",
              "hint": "What is each item in this collection? Name it properly to aid understanding."
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "Well done on your previous fixes! Now your colleague has sent you this \"masterpiece\" of clarity. \n\n\"It's short and simple,\" they said. \"Probably doesn't need any changes,\" they said. Let's see about that... I spy with my little eye some variables that are playing hide-and-seek with their meanings!",
          "finalMessage": "Excellent work! You've transformed this cryptic code into something self-documenting.\nNow anyone reading it can understand what it does without having to trace through the execution in their head.\nRemember: code is written once but read many times, so optimizing for readability is always worth the extra keystrokes!",
          "endReply": "Next challenge!"
        },
        {
          "filename": "views.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef get_views_per_second(views, date):\n"
            },
            {
              "type": "replace-on",
              "event": "MAGIC",
              "text": "",
              "replacement": "    n = 24 * 60 * 60\n"
            },
            {
              "type": "text",
              "text": "    daily_views = sum(1 for v in views if v.date == date)\n    return daily_views / 86400\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "86400",
              "replacement": "(24*60*60)",
              "event": "86400",
              "explanation": "Magic numbers like 86400 are inside jokes - funny if you're in on it, confusing for everyone else.",
              "hint": "What does this specific number represent? Think about time measurement."
            },
            {
              "type": "replace-span",
              "clickable": "(24*60*60)",
              "replacement": "n",
              "event": "MAGIC",
              "explanation": "You've replaced one magic number with another! At least now it's calculated, showing your reasoning.",
              "hint": "Names usually helps to explain calculations!"
            },
            {
              "type": "replace-span",
              "clickable": "n",
              "replacement": "seconds_in_24h",
              "event": "n",
              "explanation": "Finally! A variable name that explains what the value represents. No more reverse-engineering needed.",
              "hint": "What exactly are you calculating with 24*60*60?."
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "⚠️ IMPORTANT NOTICE ⚠️\nDo NOT change any constants here! They are magically calculated by our resident wizard who refuses to document anything.\n\nThe code works perfectly through some arcane sorcery. Touching it might summon demons or worse - break production. Proceed with extreme caution!",
          "finalMessage": "Congratulations on defying the \"don't touch the magic constants\" warning!\nSometimes the most important rules to break are the ones that lead to unmaintainable code.\nBy replacing magic numbers with clear, calculated constants, you've made this code significantly more readable and less prone to mysterious bugs.\nYour future self thanks you!",
          "endReply": "Magic dispelled!"
        },
        {
          "filename": "contains.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef contains(text, pattern):\n    l = len(pattern)\n    for i in range(len(text)):\n        if text[i:i+1] == pattern:\n            return True\n    return False\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "l",
              "replacement": "pattern_len",
              "event": "l",
              "explanation": "Lowercase 'l' as a variable name? Good way to mess it with `1` and `I`!",
              "hint": "Single character name often are source of troubles!"
            },
            {
              "type": "replace-span",
              "clickable": "i+1",
              "replacement": "i+l",
              "event": "i1",
              "explanation": "Off-by-many error? Is it a new level of the off-by-one?",
              "hint": "The slice is a bit... thin..."
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "Your colleague just pushed this \"perfectly working\" string search function to production. Customers are already complaining that the search doesn't work properly.\n\nCan you find what's lurking in this seemingly innocent code before the support team stages a revolt?",
          "startReply": "Challenge accepted!",
          "finalMessage": "Great debugging! You fixed both a naming issue and a logical bug. The original code only compared single characters to the entire pattern. Clear variable names make bugs like this easier to spot!",
          "endReply": "Bug squashed! What's next?"
        },
        {
          "filename": "unescape.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef unescape(s):\n    ss = \"\"\n    flag = False\n    for c in s:\n        if flag and c == 'n':\n            ss += '\\n'\n        elif flag and c == 't':\n            ss += '\\t'\n        elif flag and c == '\\\\':\n            ss += '\\\\'\n        elif c == '\\\\':\n            flag = True\n        else:\n            ss += c\n    return ss\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "flag",
              "replacement": "after_slash",
              "event": "flag",
              "explanation": "Flag for what? A country? A ship? 'after_slash' actually tells us what it's tracking.",
              "hint": "What condition is this boolean tracking? Think about the previous character."
            },
            {
              "type": "replace-span",
              "clickable": "ss",
              "replacement": "unescaped",
              "event": "ss",
              "explanation": "'ss'? A snake hissing? Variable names should tell a story, not just duplicate other names.",
              "hint": "What transformation is happening to this string as it's being built?"
            },
            {
              "type": "replace-span",
              "clickable": "s",
              "replacement": "escaped",
              "event": "s",
              "explanation": "Single-letter variables are mysterious characters never properly introduced. Parameters deserve full identity.",
              "hint": "What kind of string is being passed to this function?"
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "Behold! Our senior developer's \"typing efficiency\" naming convention:\n- String variables: 's', 's1', 'ss' (saves keystrokes!)\n- Booleans: always 'flag' (saves thinking time!)\n\nThis is a pure efficiency of x10 developers!",
          "startReply": "Don't think so...",
          "finalMessage": "Excellent work! You've transformed this code from a cryptic puzzle into self-documenting code. Now anyone reading it can immediately understand what each variable represents without having to trace through the execution. Remember: the goal of variable naming isn't to save keystrokes while typing - it's to save brain cycles while reading!",
          "endReply": "Names fixed!"
        },
        {
          "filename": "bigrams.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef GetBigramsFrequency(ws):\n    bigramsCount = len(ws) - 1\n    bigramsfrequency = {}\n    for I in range(bigramsCount):\n        bg = ws[I] + ' ' + ws[I + 1]\n        if bg in bigramsfrequency:\n            bigramsfrequency[bg] += 1\n        else:\n            bigramsfrequency[bg] = 1\n    return bigramsfrequency\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "GetBigramsFrequency",
              "replacement": "get_bigrams_frequency",
              "event": "GetBigramsFrequency",
              "explanation": "CamelCase in Python? That's like wearing socks with sandals - technically functional but culturally questionable. Python has its own style guide (PEP 8) that recommends snake_case for functions. Consistency in style makes code more readable for the community.",
              "hint": "This function name is dressed in CamelCase, but Python functions prefer to slither in snake_case."
            },
            {
              "type": "replace-span",
              "clickable": "bigramsCount",
              "replacement": "bigrams_count",
              "event": "bigramsCount",
              "explanation": "Another CamelCase refugee! In Python, we separate our words with underscores, not capital letters. It's not just pedantry - consistent style makes code easier to scan and understand.",
              "hint": "CamelCase in Python? That's cultural appropriation!"
            },
            {
              "type": "replace-span",
              "clickable": "I",
              "replacement": "i",
              "event": "I",
              "explanation": "A capital 'I' as a loop counter? That's just asking to be confused with the number 1 in many fonts! Single-letter variables should be lowercase, especially common ones like loop counters.",
              "hint": "Why is this loop counter SHOUTING at me?"
            },
            {
              "type": "replace-span",
              "clickable": "ws",
              "replacement": "words",
              "event": "ws",
              "explanation": "The mysterious 'ws'! Is it 'web services'? 'work sheets'? 'wild stallions'? Abbreviations save you 3 seconds typing and cost the next developer 3 minutes of confusion.",
              "hint": "ws? Web Services? Weighted Sums? Wild Stallions?"
            },
            {
              "type": "replace-span",
              "clickable": "bg",
              "replacement": "bigram",
              "event": "bg",
              "explanation": "'bg' could be 'background', 'bodyguard', or 'Bulgarian'. In a function specifically about bigrams, using the full term 'bigram' makes the code instantly more readable.",
              "hint": "bg = Bulgaria? Background? Bill Gates? Buy Gold?"
            },
            {
              "type": "replace-span",
              "clickable": "bigramsfrequency",
              "replacement": "bigrams_frequency",
              "event": "bigramsfrequency",
              "explanation": "This variable name is having an identity crisis - it can't decide if it wants to be camelCase or snake_case, so it chose neither! Consistency in naming style makes code much easier to read.",
              "hint": "This name needs some snake_case surgery. Stat!"
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "Ah, the joys of cross-language developers! Anders and Nicolaus just transferred from the C# team and brought their naming conventions with them. They insist their style is \"perfectly readable\" and \"who cares about PEP 8 anyway?\"\n\nTheir code works, but it's like showing up to a Python conference wearing a tuxedo - technically dressed, but clearly missed the memo about the dress code. Can you help them blend in with the Python community?",
          "startReply": "Time for a Python style makeover!",
          "finalMessage": "Excellent work! You've successfully converted this code to follow Python's naming conventions. While the code would work either way, following the established style guidelines for a language makes your code more readable and maintainable for other Python developers. It's like learning the local customs when you visit a new country - it shows respect for the community and helps you integrate better!",
          "endReply": "Style guide conformance achieved!"
        },
        {
          "filename": "copy.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef copy(xs, ys, j, k, n):\n    \"\"\"Copy elements from ys to xs\n\n    Args:\n        xs - destination\n        ys - source\n        j - start index in xs\n        k - start index in ys\n        n - number of elements to copy\n    \"\"\"\n    for i in range(n):\n        xs[j+i] = ys[k+i]\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "xs",
              "replacement": "destination",
              "event": "xs",
              "explanation": "Ah, 'xs'! Is that a clothing size? An abbreviation for 'excess'? The documentation already calls it 'destination' - why not use that in the code too? Consistency between docs and code prevents confusion.",
              "hint": "The docstring is practically screaming the answer at you!"
            },
            {
              "type": "replace-span",
              "clickable": "ys",
              "replacement": "source",
              "event": "ys",
              "explanation": "'ys'? Are we playing a game of 'Name That Variable: Vowel-Free Edition'? Again, the documentation already has a perfectly good name for this parameter.",
              "hint": "The answer is right above you. No, literally, look up!"
            },
            {
              "type": "replace-span",
              "clickable": "j",
              "replacement": "dest_start",
              "event": "j",
              "explanation": "Single-letter variables like 'j' are perfect when you want your code to be as mysterious as possible. For everyone else, descriptive names like 'dest_start' make the code self-documenting.",
              "hint": "j for... jumping? juggling? The docstring knows!"
            },
            {
              "type": "replace-span",
              "clickable": "k",
              "replacement": "src_start",
              "event": "k",
              "explanation": "The letter 'k' - saving valuable keystrokes since the invention of programming! But at what cost to readability? The few extra characters in 'src_start' make the code instantly more understandable.",
              "hint": "k is for... konsult the docstring!"
            },
            {
              "type": "replace-span",
              "clickable": "n",
              "replacement": "count",
              "event": "n",
              "explanation": "'n' could stand for 'number', 'node', 'noodle'... The documentation says 'number of elements to copy', so why not use a name that actually conveys that meaning?",
              "hint": "n = noodles? narwhals? The docstring has the scoop!"
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "Well, well, well... someone actually wrote documentation for their code! How quaint! \n\nBut wait - they used clear, descriptive terms in the docs, then proceeded to name their actual parameters like they were rationing letters during a keyboard shortage. It's like writing a detailed restaurant menu in beautiful prose, then serving the food in unmarked paper bags.\n\nLet's see if we can make the code as descriptive as its documentation, shall we?",
          "startReply": "Code should be as clear as its docs!",
          "finalMessage": "Excellent! You've transformed this function from cryptic to crystal clear. Now the code matches the quality of its documentation, making it immediately obvious what each parameter does without having to refer to the docstring. \n\nRemember: Good code is self-documenting. While comments and docstrings are valuable, they shouldn't be a crutch for poorly named variables. When your variable names tell the story clearly, your code becomes much easier to understand and maintain!",
          "endReply": "Documentation and code now in harmony!"
        },
        {
          "filename": "discount.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef is_discount_hunter(customer):\n    flag = True\n    for order in customer.orders:\n        flag2 = False\n        for item in order.items:\n            if item.product.discount > 0:\n                flag2 = True\n        flag = flag and flag2\n    return flag\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "flag",
              "replacement": "every_order_has_discounted_item",
              "event": "flag",
              "explanation": "Flags are for countries! Only!",
              "hint": "if flag? or if not flag? always difficult to decide..."
            },
            {
              "type": "replace-span",
              "clickable": "flag2",
              "replacement": "has_discount",
              "event": "flag2",
              "explanation": "flag2? Is that the sequel to flag1? Coming soon to theaters near you! Numbered variables are like mystery boxes - exciting until you realize you have to open them to know what's inside.",
              "hint": "flag2 = ... or flag = ...?"
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "When you already have a variable called 'flag' and need another one, do you go with:\nA) flag and flag2\nB) flag and flag1\nC) flag1 and flag2\nD) Your option...\n\nOur developer chose option A!",
          "startReply": "Option D, obviously!",
          "finalMessage": "No more boolean guessing game in the code!\nNow anyone reading this function can understand its purpose at a glance: it checks if a customer only buys orders that contain at least one discounted item.\nDescriptive variable names make code tell a story, not pose a riddle!",
          "endReply": "ready_for_next_level = True"
        },
        {
          "filename": "board.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef initialization(board_json):\n    n = board_json['size']\n    board = creating_board(n, n)\n    board_reader(board_json, board)\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "n",
              "replacement": "board_size",
              "event": "n",
              "explanation": "Ah, the mysterious 'n'! Is it a secret agent? The 14th letter of the alphabet? Or perhaps... the size of the board? Single-letter variables are like secret codes that only the original developer understands.",
              "hint": "nitrogen? narnia? nirvana?"
            },
            {
              "type": "replace-span",
              "clickable": "initialization",
              "replacement": "initialize_board",
              "event": "initialization",
              "explanation": "Functions should be verbs because they DO things! 'initialization' is the noun form - like saying 'swimming' instead of 'swim'. Your functions should sound like commands: 'create', 'calculate', 'destroy', not 'creation', 'calculation', 'destruction'.",
              "hint": "Functions DO things!"
            },
            {
              "type": "replace-span",
              "clickable": "creating_board",
              "replacement": "create_board",
              "event": "creating_board",
              "explanation": "'creating_board' sounds like you're narrating what you're doing: 'I am creating board now'. Function names should be direct commands: 'create_board!' It's more efficient and follows standard conventions.",
              "hint": "building, running, processing — are nouns!"
            },
            {
              "type": "replace-span",
              "clickable": "board_reader",
              "replacement": "read_board",
              "event": "board_reader",
              "explanation": "'board_reader' sounds like a job title, not an action. Is it a person who reads boards professionally? Functions should be verbs that describe the action they perform.",
              "hint": "Writer, reader, manager — are nouns!"
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "Your colleague, who apparently skipped the \"Parts of Speech\" day in English class, has written some board game initialization code.\n\nThey proudly explained: \"It is simple! The 'initialization' consists of 'creating a board' and filling it with the 'board_reader'!\"\n\nTime to teach them the sacred rule of naming: functions — verbs, variables — nouns.",
          "startReply": "Let me fix these names...",
          "finalMessage": "Excellent work! You've transformed these function and variable names to follow proper naming conventions. Functions are now verbs (actions) and variables are nouns (things), making the code much more intuitive to read.\n\nThis naming pattern creates a natural language-like flow in your code: \"initialize_board takes a board_size and uses it to create_board and read_board.\" It reads almost like a sentence, which is exactly what good code should do!",
          "endReply": "Grammar fixed!"
        },
        {
          "filename": "final.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef InstructionParser(i):\n    Instructions = []\n    F = False\n    for l in i.splitlines():\n        if l.startswith(\"BEGIN\"):\n            F = True\n        if not F:\n            continue\n        if l.startswith(\"END\"):\n            F = False\n        elif l.startswith(\"replace \"):\n            rest = l[8:]\n            old, new = rest.split(\" with \")\n            Instructions.append((\"replace\", old, new))\n        elif l.startswith(\"add \"):\n            rest = l[4:]\n            Instructions.append((\"add\", rest))    \n        else:\n            raise Exception(\"Unknown instruction in line: \" + l)\n    return Instructions\n\n"
            },
            {
              "type": "replace-span",
              "clickable": "InstructionParser",
              "replacement": "parse_instructions",
              "event": "InstructionParser",
              "explanation": "CamelCase function names in Python? That's like wearing a tuxedo to a beach party. Python has its own dress code (PEP 8), and it strongly recommends snake_case for functions. Also, functions should be verbs because they DO things - they're not just sitting around being nouns.",
              "hint": "CamelCase in Python? And it's not even a verb! Double whammy!"
            },
            {
              "type": "replace-span",
              "clickable": "Instructions",
              "replacement": "instructions",
              "event": "Instructions",
              "explanation": "Why is 'Instructions' capitalized? Is it royalty? A proper noun? The beginning of a sentence? In Python, variable names should be snake_case and lowercase unless they're constants (which this definitely isn't).",
              "hint": "Why is this variable SHOUTING its first letter? Royalty?"
            },
            {
              "type": "replace-span",
              "clickable": "F",
              "replacement": "inside_begin_end",
              "event": "F",
              "explanation": "Ah, the enigmatic 'F'! Is it paying respects? A grade? The sixth letter of the alphabet? Single-letter variables are like secret codes that only the original developer understands - and sometimes not even them after a few months.",
              "hint": "F = Fahrenheit? Failure? Friday? Press F to pay respects?"
            },
            {
              "type": "replace-span",
              "clickable": "l",
              "replacement": "line",
              "event": "l",
              "explanation": "The letter 'l' is particularly problematic as a variable name because in many fonts it looks identical to the number '1'. It's like setting a trap for the next developer (or yourself in 3 months).",
              "hint": "Is that an 'l', a '1', or an 'I'? Font roulette!"
            },
            {
              "type": "replace-span",
              "clickable": "i",
              "replacement": "instructions_text",
              "event": "i",
              "explanation": "The lonely 'i' parameter! Is it an index? An iterator? An imaginary number? When parameters are the entry point to your function, they deserve names that clearly explain what they contain.",
              "hint": "i = index? iterator? imaginary number? iPhone?"
            },
            {
              "type": "replace-span",
              "clickable": "4:",
              "replacement": "len(\"add \"):",
              "event": "4",
              "explanation": "Magic numbers like '4' are like mysterious ingredients in a recipe. 'Add a pinch of 4' - but why 4? What does it represent? Using 'len(\"add \")' makes it immediately clear you're skipping past a command prefix.",
              "hint": "Why 4? The answer is right in front of you... literally!"
            },
            {
              "type": "replace-span",
              "clickable": "8:",
              "replacement": "len(\"replace \"):",
              "event": "8",
              "explanation": "Another magic number! '8' is the lucky number in some cultures, but in code, unexplained numbers are just bad luck waiting to happen. What if the command syntax changes? You'd have to hunt down all these hardcoded values.",
              "hint": "8 is lucky in some cultures, unlucky in your code. Count the letters!"
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "BEHOLD! I have crafted the most exquisite piece of code known to humanity! It's so perfect that it probably doesn't even need electricity to run - the sheer elegance of its logic could power a small city.\n\nAccording to our tedious team process, someone needs to review it. But let's be honest - this is just a formality. Simply approve it and we can all go home early!",
          "startReply": "Perfect!",
          "finalMessage": "Congratulations! You've transformed this \"perfect\" code into something actually worthy of approval. \n\nYou've applied all the naming best practices we've covered:\n1. Using snake_case for Python functions and variables\n2. Making function names verbs that describe their action\n3. Using descriptive names instead of single letters or abbreviations\n4. Replacing magic numbers with self-documenting expressions\n\nRemember: Code isn't just for computers to execute - it's for humans to read, understand, and maintain. Good naming is the foundation of readable code, and readable code is the foundation of maintainable software.\n\nYou've completed the naming challenges! Your future teammates thank you in advance for your clear, descriptive naming practices.",
          "endReply": "Is it a promotion?"
        }
      ]
    },
    {
      "name": "Pythonic Code",
      "wisdoms": [
        {
          "id": "built-in-functions",
          "text": "Use Python's built-in functions instead of reinventing the wheel."
        },
        {
          "id": "list-comprehensions",
          "text": "List comprehensions and generator expressions are more concise and often more readable than loops."
        },
        {
          "id": "context-managers",
          "text": "Use context managers (with statement) for resource management."
        },
        {
          "id": "in-operator",
          "text": "The 'in' operator is a powerful and efficient way to check for membership."
        }
      ],
      "levels": [
        {
          "filename": "sum.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef print_sum_and_min(values):\n"
            },
            {
              "type": "replace",
              "text": "    sum_all = 0\n    for i in values:\n        sum_all += i\n",
              "replacement": "    sum_all = sum(values)\n",
              "event": "sum_loop",
              "explanation": "Why use an abacus when you have a calculator? Python's sum() is faster and less error-prone.",
              "hint": "Why build a calculator when there's one in your pocket?"
            },
            {
              "type": "replace",
              "text": "    min_value = values[0]\n    for v in values[1:]:\n        if v < min_value:\n            min_value = v\n",
              "replacement": "    min_value = min(values)\n",
              "event": "min_loop",
              "explanation": "Manual min-finding is dangerous and verbose. Python's min() is safer and cleaner.",
              "hint": "Finding minimums manually? What is this, the stone age?"
            },
            {
              "type": "text",
              "text": "    print(f\"sum: {sum_all}, min: {min_value}\")\n\"\"\"final\nExcellent! Pythonic code!\n\nPython's built-in functions make your code more readable, concise, and often faster.\nRemember: \"Flat is better than nested\" and \"Simple is better than complex\" - core principles from the Zen of Python.\n\"\"\"\n"
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "Ah, I see your colleague is a fan of \"artisanal, hand-crafted loops\" - painstakingly constructing each calculation from scratch like it's 1995!\n\nThey probably also churn their own butter and forge their own paperclips. How quaint! Let's introduce them to this revolutionary concept called \"built-in functions\" that Python has had since... forever.",
          "startReply": "Let's modernize!",
          "endReply": "Built-ins for the win!"
        },
        {
          "filename": "csv_processing.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef list_to_csv(nums):\n"
            },
            {
              "type": "replace",
              "text": "    csv = \"\"\n    for n in nums:\n        csv += str(n) + \",\"\n    if csv.endswith(\",\"):\n        csv = csv[:-1]\n    return csv\n",
              "replacement": "    return \",\".join(str(n) for n in nums)\n",
              "event": "csv_join",
              "explanation": "String concatenation in loops is inefficient. Join() is faster and handles edge cases.",
              "hint": "Concatenating strings in a loop? That's so 1990s!"
            },
            {
              "type": "text",
              "text": "\ndef count_zeros(values):\n"
            },
            {
              "type": "replace",
              "text": "    count = 0\n    for v in values:\n        if v == 0:\n            count += 1\n    return count\n",
              "replacement": "    return sum(1 for v in values if v == 0)\n",
              "event": "count_zeros",
              "explanation": "Generator expressions are elegant and efficient. Count zeros without the loop bloat.",
              "hint": "Why count manually when Python can do the math for you?"
            },
            {
              "type": "text",
              "text": "\ndef uppercase_file(filename):\n"
            },
            {
              "type": "replace",
              "text": "    file_obj = open(filename, 'r', encoding='utf-8')\n    big_text = file_obj.read().upper()\n    file_obj.close()\n    return big_text\n",
              "replacement": "    with open(filename, 'r', encoding='utf-8') as f:\n        return f.read().upper()\n",
              "event": "with_open",
              "explanation": "The 'with' statement auto-closes files, even after exceptions. No more resource leaks!",
              "hint": "Forgetting to close files? There's a 'with' for that!"
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "Oh look, another \"for loop enthusiast\" who never met a loop they didn't like! \n\nThis code has more unnecessary loops than a roller coaster factory. It's like watching someone dig a hole with a spoon when there's a perfectly good shovel nearby. Let's introduce them to some Pythonic constructs that can save both keystrokes and sanity!",
          "startReply": "Let's Pythonize it!",
          "finalMessage": "Bravo! You've transformed verbose code into elegant, Pythonic expressions.\n\nPython's powerful constructs (join, generator expressions, context managers) aren't just shortcuts - they're the idiomatic way to write Python. Remember: \"There should be one obvious way to do it.\"",
          "endReply": "Pythonic elegance achieved!"
        },
        {
          "filename": "search.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef contains(text, pattern):\n"
            },
            {
              "type": "replace",
              "text": "    pattern_len = len(pattern)\n    for i in range(len(text)):\n        if text[i:i+pattern_len] == pattern:\n            return True\n    return False\n",
              "replacement": "    # Do we really need this function?!\n    return pattern in text\n",
              "event": "in_operator",
              "explanation": "Why reinvent the wheel? The 'in' operator is concise, optimized, and already built-in.",
              "hint": "Python has a built-in way to check string containment. No loops needed!"
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "Wait a minute... didn't we just fix a 'contains' function in another file? \n\nOh, I see what happened. Your colleague fixed the bug in the previous version but still didn't realize that Python has this magical thing called the 'in' operator. It's like they fixed a leaky boat with duct tape when there was a perfectly good yacht available!\n\nLet's put this poor function out of its misery once and for all.",
          "startReply": "Use built-ins!",
          "finalMessage": "Perfect! You've replaced a manual algorithm with Python's built-in 'in' operator.\n\nThis is classic Pythonic code - using built-in features instead of reinventing them. The 'in' operator is concise, readable, efficient, and less error-prone.",
          "endReply": "Built-in operators FTW!"
        },
        {
          "filename": "unescape.py",
          "wisdoms": [],
          "blocks": [
            {
              "type": "text",
              "text": "\ndef unescape(text):\n"
            },
            {
              "type": "replace",
              "text": "    result = \"\"\n    escaping = False\n    for char in text:\n        if escaping:\n            if char == 'n':\n                result += '\\n'\n            elif char == 't':\n                result += '\\t'\n            elif char == '\\\\':\n                result += '\\\\'\n            # ... other escape sequences here...\n            else:\n                result += '\\\\' + char  # unknown escape — keep as-is\n            escaping = False\n        elif char == '\\\\':\n            escaping = True\n        else:\n            result += char\n    return result\n",
              "replacement": "    # Python rule 101: everything is already implemented in some standard function!\n    return text.encode('utf-8').decode('unicode_escape')\n",
              "event": "encode_decode",
              "explanation": "20 lines of manual character parsing versus a single line of built-in functionality! This is like building your own calculator when there's one right there in your pocket. Python's encoding/decoding system already handles all escape sequences, including ones your manual version doesn't even support!",
              "hint": "Unescaping strings is such a common operation that Python must have a built-in way to handle it. Think about string encoding and decoding..."
            },
            {
              "type": "text",
              "text": "\n"
            }
          ],
          "startMessage": "Unescape function? Again?! \n\nFirst we fixed the terrible variable names, and now we're back to fix the implementation itself. It's like your colleague is determined to solve problems that Python already solved years ago!\n\nThis manual character-by-character parsing is impressive in its thoroughness... and completely unnecessary. Let's see if we can replace this 20-line state machine with something more... Pythonic.",
          "startReply": "There must be a built-in way to do this!",
          "finalMessage": "Excellent! You've replaced a complex manual implementation with Python's built-in functionality.\n\nThis is a perfect example of the \"batteries included\" philosophy of Python. Before implementing any non-trivial functionality, it's always worth checking if Python's standard library already has a solution. In this case, the encode/decode approach:\n\n1. Is much more concise (1 line vs 20)\n2. Handles all standard escape sequences, not just the few explicitly coded\n3. Is likely more efficient as it's implemented in C\n4. Has been thoroughly tested by the Python community\n\nRemember: \"There should be one-- and preferably only one --obvious way to do it.\" In Python, the obvious way is usually the built-in way!",
          "endReply": "Batteries included indeed!"
        }
      ]
    }
  ]
}