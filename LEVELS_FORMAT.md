## 4. Data Model

The Clean-Code Game uses a single `levels.json` to store levels, topics and wisdoms.
It is generated by toolchain from a source levels directory with topic descriptions in `JSON` format and level
descriptions in `PyLevels` format.

---

### Source Levels Directory

```
levels
  - 01-naming
	- topic.json
    - 01-level1.py
	- 02-level2.py
  - 02-decomposition
    - topic.json
    - 01-level1.py
	...
  ...
```

Each directory in `levels` folder with `topic.json` ‚Äî‚Äî is a topic folder.

* folder name defines the order of the topics in game.
* topic.json defines a topic:

  ```json
  {
      "name": "Naming",
      "wisdoms": [
          {
              "id": "wisdomId",
              "text": "some wisdom"
          }
      ]
  }
  ```

### ‚úçÔ∏è PyLevels Format (Level Source Format)

Each .py file in topic directory defines one level. Name of the file defines order of the levels in the topic.

Levels file starts with header directives followed by sequence of blocks.

---

#### üîπ Header Directives

```text
##level readable_title.py           # Required ‚Äî used as display title in UI
##wisdoms id1 id2 ...               # Optional ‚Äî wisdoms unlocked on level complete
```

#### üîπ Chat Messages

```text
"""buddy
Chat message from buddy
"""
##reply "Player's reply"            # Optional ‚Äî player's response to buddy
```

---

### #üîπ Block Types

##### 1. Plain Text Block

Text not following a directive is treated as a normal block of visible text.

```text
This is a simple explanation or code section.
```

---

##### 2. Replace Span

Replaces a substring when clicked and triggers EVENT_ID.
If `-` used for EVENT_ID, then toolchain generates unique event id.

```text
##replace-span EVENT_ID CLICKABLE_SUBSTRING REPLACEMENT
```

---

##### 3. Replace

Replaces one or more lines of code when clicked. Can optionally narrow the clickable area with a substring.

```text
##replace EVENT_ID
<code lines...>
##with
<replacement lines...>
##end
```

With specific clickable area:

```text
##replace EVENT_ID CLICKABLE_SUBSTRING
<code lines...>
##with
<replacement lines...>
##end
```

If `-` used for EVENT_ID or EVENT_ID is missing, then toolchain generates unique event id.

---

##### 4. Neutral feedback

Neutral feedback for subjective issues. May appear anywhere.

```text
##neutral CLICKABLE_SUBSTRING
```

---

##### 5. Explanations and Hints

```text
##explain EXPLANATION
```

Can appear only after blocks triggering events: `replace`, `replace-span` or `neutral` block. Add explanation to prev
block.

```text
##hint EXPLANATION
```

Can appear only after `replace-block` and `replace-span`. Add hint to prev block.

##### 6. Replace On

Replaces a block only **after another event has triggered**. Must reuse an existing EVENT_ID.

```text
##replace-on EVENT_ID
<code lines...>
##with
<replacement lines...>
##end
```

---

##### 7. Add On (Syntactic Sugar)

```text
##add-on EVENT_ID
<code lines...>
##end
```

equivalent to

```text
##replace-on EVENT_ID
##with
<code lines...>
##end
```

##### 8. Remove On (Syntactic Sugar)

```text
##remove-on EVENT_ID
<code lines...>
##end
```

equivalent to

```text
##replace-on EVENT_ID
<code lines...>
##with
##end
```

#### üîê Additional Rules

- **CLICKABLE_SUBSTRING**, **REPLACEMENT**, **EXPLANATION** may be enclosed in quotation marks (single or double).
  In that case (and only in that case) escape sequences and spaces can be used in them to represent multiline substrings
  or substrings with spaces.
- EXPLANATION may be in the format `$wisdomId`. In that case text of the wisdom with id=wisdomId should be used.
- All whitespace and formatting is preserved
- EVENT_ID may be the same for several replacement blocks. In that case triggering any of these blocks executes all the
  replacements with the same EVENT_ID
- CLICKABLE substring occurrence counts only if it is surrounded by word-boundaries.

---

### üßæ levels.json Format

Web-application work with this json format:

```json
{
	"topics": [
		{
			"name": "Naming",
			"wisdoms": [
				{
					"id": "wisdomId",
					"text": "some wisdom"
				} 
			],
			"levels": [

			]
		}
	]
}
```

Each level is compiled into a single JSON object with the following structure:

```json
{
  "filename": "onboarding.py",
  "chat": {
    "buddy": "Hello, Junior! This is your first task!",
    "reply": "Ok"
  },
  "wisdoms": ["naming-descriptive", "keep-it-simple"],
  "blocks": [
    {
      "type": "text",
      "text": "val answer: Int = 42\nval question: String? = null"
    },
    {
      "type": "replace-span",
      "clickable-substring": "foo",
      "replacement": "describe_user",
      "event": "rename-function",
	  "explanation": "this is optional explanation",
	  "hint": "some optional hint"
    },
    {
      "type": "replace",
      "text": "def foo():\n    print('Hello')",
      "replacement": "def describe_user():\n    print('Hello')",
      "event": "rename-function",
	  "explanation": "this is optional explanation",
	  "hint": "some optional hint"
    },
    {
      "type": "replace-on",
      "text": "print(foo())",
      "replacement": "print(describe_user())",
      "event": "rename-function"
    },
  ]
}
```

This structure is designed for easy rendering in the frontend and consistent mapping from the authoring format.
